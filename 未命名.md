可以。把 OCR 改成**本地开源**后，整体仍然能保持“主要算力依赖外接大模型 API”，因为 OCR 只负责**页码定位所需的 bbox**（坐标与文本行），而语义比对/改写识别/解释依旧走 LLM。下面把方案按“本地开源 OCR”为前提，给你一套可直接落地的技术决策与开发要点。

---

## 1) OCR 技术选型（开源、本地、中文优先）

### 推荐主方案：PaddleOCR

* 适用：中文扫描 PDF、盖章页、表格、图文混排
* 输出：行/词级 bbox + 文本 + 置信度（满足高亮）
* 配套：`PP-OCRv4`（识别）+ `det`（检测）
* 可选结构化：`PP-Structure`（表格/版面结构，二期再加）

---

## 2) 本地 OCR 的“省算力策略”（你必须这样做，否则会慢）

你们标段≤20份，扫描件占比不确定，本地 OCR 一定要“按需”：

### 2.1 先判定是否需要 OCR（每页级）

对每页做快速检测：

* PDF 可抽到文本层且文本长度 > 阈值（比如 > 50 字）→ **不 OCR**
* 否则：该页标记 `need_ocr=true`

### 2.2 OCR 只做“疑似页”而不是全量

推荐默认策略（STANDARD 模式）：

1. 先做轻量候选（基于可解析文本页、目录、页数/结构）
2. LLM 对齐后得到“疑似章节/块的页范围”（page hints）
3. **只对这些 page hints OCR**
4. 每份文档 OCR 页数上限：默认 10 页（可配置），超过则提示“可继续补全”

> 这样 OCR 成本从“全书”变成“关键页”，对本地算力压力小很多。

### 2.3 OCR 缓存（页级强缓存）

* `ocr_cache_key = sha256(page_image_bytes + ocr_model_version + dpi)`
* 同一页重复上传/重复任务：直接复用结果（非常关键）

---

## 3) 页码定位闭环（本地 OCR 版本的关键点）

目标仍然是统一产出 `doc_line`（行级）：

* 可解析 PDF：直接抽 `doc_line(page,bbox,text)`
* 扫描页：OCR 输出 lines → 写 `doc_line(page,bbox,text,confidence)`

### bbox 坐标存储建议

继续使用**归一化坐标** `[x1,y1,x2,y2]`（0..1）：

* OCR 引擎返回的是像素坐标，除以页宽高即可归一化
* 前端 PDF.js 渲染时按 viewport 还原成像素，缩放不会漂

---

## 4) 后端架构要调整的地方（很少）

你之前的 `ocr-adapter` 仍然保留，但它不再调用外部服务，而是：

* `ocr-worker`：消费队列任务 → 渲染页图 → PaddleOCR → 写库 + 写缓存
* `anchor-service`：负责判定哪些页需要 OCR、生成 OCR 子任务

### 推荐部署形态

* 一个独立 `ocr-worker` 进程（可水平扩展）
* 允许配置并发：默认 1~2（看机器）

---

## 5) OCR 实现细节（开发可直接照这个做）

### 5.1 PDF 页渲染（给 OCR 的输入）

* 扫描 PDF 必须先渲染成图片（建议 200–300 DPI）
* 300 DPI 更准但更慢；默认 200 DPI，命中区域再提高 DPI（二期可做）

### 5.2 OCR 输出结构（统一标准）

把 OCR 输出统一成：

```json
{
  "page": 12,
  "lines": [
    {"text":"...", "bbox":[x1,y1,x2,y2], "confidence":0.92}
  ]
}
```

落库就是 `doc_line`。

### 5.3 与 LLM 的接口衔接（仍然用 spans→bbox）

* LLM 输出 matched_spans（句子/片段）
* 后端在 `doc_line.norm_text` 里匹配到若干行 → bbox_list
* 前端高亮无需知道 OCR 细节

---

## 6) 成本/性能预期（≤20份文件的现实参数）

在一台普通服务器（比如 8C16G）：

* 可解析 PDF：基本秒级出锚定
* 扫描件 OCR：取决于页数

  * 按“疑似页 ≤10/份”估算：总体可控
* LLM 调用：仍是主要耗时来源（但你希望算力走 API，这点没问题）

建议默认参数（STANDARD）：

* OCR 并发：1（稳定优先）
* 每份 OCR 页上限：10
* 超过上限：报告标记 `PARTIAL`，前端可点“继续补全 OCR”

---

## 7) 你现在是否能开工？

能，而且更明确了：**OCR 本地开源**只是把“Provider 配置”从外部变成内部 worker，不影响主链路设计。开工前要在技术评审里一次定死的仅剩两点：

1. PaddleOCR 具体模型与版本（固定下来写进 `ocr_model_version`，用于缓存 key）
2. PDF 页渲染方案与 DPI 默认值（200 or 300，建议先 200）

---

下面把你要的两块补齐到“研发拿去就能做”的程度：

1. **本地开源 OCR 子系统详细设计**（任务、队列、并发、缓存、重试、监控、表结构补充）
2. **Vue3 CompareViewer 高亮实现细节**（归一化 bbox → PDF.js viewport 坐标换算、双栏同步、性能要点）

---

# 1）OCR 子系统详细设计（本地 PaddleOCR）

## 1.1 子系统目标与边界

**目标**：为“页码定位与高亮”提供 `doc_line(page_no + bbox + text + confidence)`。
**不做**：语义比对、相似度判断（这些交给 LLM）。

**输入**：doc_id/version_id + page_no 列表
**输出**：写入 `doc_line`（行级）+ 记录 OCR 状态/日志 + 缓存命中

---

## 1.2 组件与职责（建议两个 worker）

### A) Anchor Service（主流程服务）

职责：

* 判断哪些页需要 OCR（page-level）
* 生成 OCR 任务并入队
* 维护 doc_version/parse_status、doc_page.has_text_layer、doc_page.image_url（可选）

### B) OCR Worker（独立进程，可横向扩展）

职责：

* 拉取任务
* 渲染指定页为图片（DPI 可配置）
* PaddleOCR 推理 → lines（text+bbox+conf）
* 坐标归一化
* 写库（doc_line）+ 写缓存（llm_cache 类似方式）+ 写任务状态
* 失败重试与降级

> 强烈建议把 OCR 做成独立 worker，避免阻塞 API。

---

## 1.3 任务模型（队列消息）

建议队列消息结构（JSON）：

```json
{
  "task_id": "uuid",
  "job_id": "uuid",
  "doc_id": "uuid",
  "version_id": "uuid",
  "page_no": 12,
  "render_dpi": 200,
  "ocr_model_version": "paddleocr-ppocrv4",
  "priority": 5,
  "created_at": 1700000000
}
```

### 优先级策略（实用）

* CompareViewer 正在查看的命中页：priority=1（最高）
* 标准查重批量 OCR：priority=5
* 补全任务（用户点击“继续补全”）：priority=3

队列实现：

* Redis Streams + consumer group（推荐易落地）
* 或 RabbitMQ 优先级队列（更标准）

---

## 1.4 “是否需要 OCR”的判定规则（非常关键）

在 Anchor Service 做页面级快速检测：

**规则：**

1. 如果 PDF 页提取到的文本字符数 > `MIN_TEXT_LEN`（默认 50）→ `has_text_layer=true`，不 OCR
2. 否则 `has_text_layer=false`，加入 OCR 候选页
3. 额外增强：若页面图片对象占比高/文本对象少（pdf 解析能拿到对象统计更好）→ 倾向 OCR
4. 对 docx：先转 pdf，再按上述规则

**落库：**

* `doc_page.has_text_layer`
* `doc_page.image_url`（可选：缓存渲染页图）

---

## 1.5 OCR 渲染与归一化坐标

### 1.5.1 页渲染（PDF → image）

建议：

* 默认 200 DPI（速度优先）
* 若某页 OCR 置信度整体偏低或命中定位困难，可二次渲染 300 DPI（按需、少量）

渲染输出：

* `img_width_px`, `img_height_px`

### 1.5.2 PaddleOCR 输出 → 归一化 bbox

PaddleOCR 常见输出是四点 polygon（四个角点）。你需要转成轴对齐矩形 bbox：

* `x1 = min(x_i)`, `y1 = min(y_i)`, `x2 = max(x_i)`, `y2 = max(y_i)`
* 归一化：

  * `nx1 = x1 / img_width`, `ny1 = y1 / img_height`, `nx2 = x2 / img_width`, `ny2 = y2 / img_height`

写入 `doc_line.bbox = [nx1, ny1, nx2, ny2]`

---

## 1.6 doc_line 规范化与质量控制

### 1.6.1 norm_text 规则（与 LLM/匹配一致）

* 全角转半角、统一标点
* 连续空白压缩
* 去掉页眉页脚（如果你能检测到：在页顶部/底部且重复率高的行）
* 可选：数字归一化（用于“改写式”匹配时更稳，比如把连续数字替换成 `<NUM>`）

### 1.6.2 低置信度处理

* line.confidence < 0.5：仍可入库，但标记低可信
* CompareViewer 高亮时：低可信框用更淡的样式（前端可选）

---

## 1.7 OCR 缓存与表结构补充（推荐新增两张表）

你已有 `llm_cache`。OCR 建议单独缓存，避免 doc_line 重写：

```sql
create table ocr_cache (
  cache_key         char(64) primary key,
  doc_id            uuid not null,
  page_no           int not null,
  render_dpi        int not null,
  ocr_model_version text not null,
  response_json     jsonb not null,  -- lines: [{text,bbox,conf}]
  created_at        timestamptz not null default now()
);

create table ocr_task (
  task_id           uuid primary key,
  job_id            uuid,
  doc_id            uuid not null,
  version_id        uuid not null,
  page_no           int not null,
  status            text not null, -- PENDING/RUNNING/SUCCESS/FAILED
  attempts          int not null default 0,
  last_error        text,
  created_at        timestamptz not null default now(),
  updated_at        timestamptz not null default now(),
  unique(doc_id, version_id, page_no)
);
```

**缓存 key：**
`sha256(doc_sha256 + page_no + render_dpi + ocr_model_version)`

---

## 1.8 重试、幂等、并发（落地规则）

### 幂等

* `ocr_task` unique(doc_id, version_id, page_no)
* worker 取到 task 后先把 status 从 PENDING→RUNNING（乐观锁或 where status=PENDING）

### 重试

* attempts < 2：指数退避（例如 10s、30s）
* 超过：FAILED，job 标记 PARTIAL，不阻塞主流程

### 并发

* 每个 worker 进程并发 1~2（视机器）
* 单 job OCR 并发上限 2（避免同时 OCR 太多页）

---

## 1.9 监控指标（建议最少这些）

* OCR 吞吐：pages/min
* OCR 延迟：p50/p95（按 DPI 区分）
* OCR 失败率：按错误类型
* 缓存命中率：ocr_cache hit%
* 平均每份文件 OCR 页数（帮助优化阈值）

---

# 2）CompareViewer 高亮与坐标换算（Vue3 + PDF.js）

## 2.1 坐标体系约定（必须一致）

后端存储 bbox：**归一化** `[x1,y1,x2,y2]`，范围 0..1，相对于**页面宽高**（不是整份文档）。

前端渲染时，需要：

* 获取 PDF.js 当前页的 viewport（含 scale、rotation）
* 将归一化坐标转成 CSS 像素坐标，并绘制 overlay rect

---

## 2.2 归一化 bbox → 页面像素 bbox（核心公式）

设：

* 当前页渲染的 DOM 容器尺寸为 `pageDiv.clientWidth/Height`（更可靠）
* 或使用 viewport 的 width/height（也可）

则：

```ts
px1 = nx1 * pageWidthPx
py1 = ny1 * pageHeightPx
px2 = nx2 * pageWidthPx
py2 = ny2 * pageHeightPx
w = px2 - px1
h = py2 - py1
```

**注意**：PDF.js 页面内坐标原点在左上角（通常），你用 pageDiv 尺寸换算就不会踩 rotation 坑（一期默认不支持旋转也没问题）。若你要支持 rotation（二期），用 viewport.convertToViewportPoint 处理更稳。

---

## 2.3 推荐实现：基于 pageDiv 尺寸的 Overlay

### 组件结构

* `PdfViewer.vue`

  * 内部用 PDF.js viewer 渲染页面
  * 每个 pageDiv 上挂一个 overlay 容器（absolute）
* `PdfOverlay.vue`

  * 接收当页 highlights，渲染多个矩形框

### Overlay DOM 结构（每页一个）

```html
<div class="page" data-page-number="12">
  <canvas class="canvasWrapper"></canvas>
  <div class="textLayer"></div>
  <div class="annotationLayer"></div>
  <div class="overlayLayer"></div> <!-- 你加的 -->
</div>
```

CSS 要点：

* `.overlayLayer { position:absolute; left:0; top:0; right:0; bottom:0; pointer-events:none; }`
* `.highlightRect { position:absolute; border-radius:6px; }`

---

## 2.4 高亮渲染算法（每次跳页/缩放都要刷新）

### 输入（后端 anchors）

```ts
type Highlight = { page: number; bboxList: [number,number,number,number][] }
```

### 渲染步骤

1. 当前页 pageNo 变化（跳页、滚动进入新页）
2. 找到对应 `pageDiv`
3. overlayLayer 清空
4. 遍历 bboxList，将归一化 bbox 转成 pageDiv 像素，插入 rect div

### 伪代码（核心逻辑）

```ts
function renderHighlights(pageDiv: HTMLElement, bboxList: number[][]) {
  const overlay = pageDiv.querySelector('.overlayLayer') as HTMLElement;
  overlay.innerHTML = '';

  const w = pageDiv.clientWidth;
  const h = pageDiv.clientHeight;

  for (const [x1,y1,x2,y2] of bboxList) {
    const rect = document.createElement('div');
    rect.className = 'highlightRect';
    rect.style.left = `${x1 * w}px`;
    rect.style.top = `${y1 * h}px`;
    rect.style.width = `${(x2 - x1) * w}px`;
    rect.style.height = `${(y2 - y1) * h}px`;
    overlay.appendChild(rect);
  }
}
```

---

## 2.5 双栏同步与命中导航（实用做法）

### 2.5.1 命中导航状态

在 CompareViewer store 里维护：

* `anchors[]`（每条含 A/B 的 page+bbox）
* `currentIndex`
* `syncScroll`（开关）
* `lastJumpAt`（防抖）

点击“下一处”：

* `currentIndex++`
* `leftViewer.goTo(anchors[i].a.page)`
* `rightViewer.goTo(anchors[i].b.page)`
* `leftViewer.setHighlights(anchors[i].a.bbox_list)`
* `rightViewer.setHighlights(anchors[i].b.bbox_list)`

### 2.5.2 同步滚动（建议一期做“同步跳页”，不做精细滚动同步）

精细同步滚动很容易出坑（不同页高度、缩放不同）。一期建议：

* 默认只同步“跳页”
* “同步滚动”作为可选开关，且只在两侧缩放一致时启用

---

## 2.6 性能要点（避免卡顿）

* 命中列表虚拟滚动（命中可能很多）
* 高亮只渲染当前页（不要一次把所有页 bbox 都画）
* bboxList 过多时（比如一页几十个框）：

  * 合并相邻框（同一行/同一段）可选做法
* PDF.js 加载：

  * 预览 PDF URL 必须走 CDN/对象存储加速
  * 先加载首屏页，再渐进加载

---

## 2.7 误差与漂移的常见坑（给研发踩坑提示）

1. **bbox 坐标来源不一致**：PDF 文本层 vs OCR 的 bbox 分布不同

   * 解决：都存归一化 bbox，前端统一换算
2. **DOCX 转 PDF 导致分页变化**：必须以“预览 PDF”为最终页码标准

   * 解决：锚定基于预览 PDF（方案已定）
3. **不同 DPI 影响 OCR bbox**：dpi 变更必须写进 cache_key
4. **缩放后高亮不跟随**：一定要在 zoom 事件后重算 bbox（或使用 pageDiv 实时宽高）

---

# 3）你们现在可以直接开工的“任务清单”（按模块）

## Sprint 1：OCR 子系统 + 预览高亮闭环

* [ ] docx→pdf 转换与预览 URL
* [ ] PDF 文本层抽取 doc_line（page+bbox+text）
* [ ] OCR 队列 + ocr_worker（PaddleOCR）+ doc_line 入库
* [ ] Vue3 CompareViewer：双栏 PDF.js + bbox 高亮（mock anchors → 真 anchors）

## Sprint 2：LLM 对齐/精算 + spans→bbox

* [ ] LLM provider 配置 + 调用治理 + llm_cache
* [ ] align/compare schema 校验
* [ ] spans→doc_line 匹配生成 bbox_list
* [ ] ReportOverview/HitList + 跳转对照

## Sprint 3：稳定性与运营化

* [ ] OCR 缓存 + 失败重试 + PARTIAL 报告
* [ ] 审计页 invoke_log
* [ ] 导出报告

---





