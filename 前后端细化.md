下面我把「前端细化（Vue3 B端）」和「后端细化（任务编排/幂等/缓存/DDL/错误码）」两块一次性补齐到**可开工级**。

---

# A. 前端细化（Vue3 经典 B 端 Web）

## A1. 技术栈与工程约定

* Vue 3 + Vite + TypeScript
* Router：vue-router
* 状态：Pinia
* UI：Element Plus（典型 B 端）
* PDF 预览：PDF.js（强烈建议自己封装组件）
* 请求：axios（统一拦截器、错误码映射）
* 权限：路由 meta + 后端 RBAC（至少 admin / reviewer）

工程目录建议：

```
src/
  api/                 // 封装后端接口
  assets/
  components/
    Pdf/
      PdfViewer.vue
      PdfOverlay.vue
      usePdfViewer.ts
    Dedup/
      HitList.vue
      EvidenceCard.vue
      PairMatrixHeatmap.vue
  layouts/
  pages/
    section/
      SectionList.vue
      SectionDetail.vue
    dedup/
      JobList.vue
      JobDetail.vue
      ReportOverview.vue
      CompareViewer.vue
    config/
      ProviderConfig.vue
      PromptConfig.vue
      RuleThresholdConfig.vue
    audit/
      InvokeLog.vue
  router/
  store/
  utils/
```

---

## A2. 路由信息架构（Vue Router）

```ts
[
  { path: '/sections', component: SectionList },
  { path: '/sections/:id', component: SectionDetail }, // 文件列表 + 发起查重

  { path: '/dedup/jobs', component: JobList },
  { path: '/dedup/jobs/:jobId', component: JobDetail }, // pair 列表/进度

  { path: '/dedup/reports/:reportId', component: ReportOverview },
  { path: '/dedup/compare/:hitId', component: CompareViewer }, // 双栏跳页高亮（核心）

  { path: '/config/providers', component: ProviderConfig, meta:{role:'admin'} },
  { path: '/config/prompts', component: PromptConfig, meta:{role:'admin'} },
  { path: '/config/rules', component: RuleThresholdConfig, meta:{role:'admin'} },

  { path: '/audit/invoke-log', component: InvokeLog, meta:{role:'admin'} }
]
```

---

## A3. 页面级交互与组件拆分

### A3.1 标段详情页 SectionDetail（文件列表 + 发起查重）

**UI**

* 顶部：标段信息（标段编号/名称/开标时间/文件数量）
* 主区：投标文件表格（≤20）

  * 列：投标人、文件名、文件类型、是否扫描件、解析状态、上传时间、操作（预览/替换）
* 右侧（或弹窗）：发起查重

  * 模式：快速/标准/深度
  * 模型选择（默认某 provider）
  * 阈值模板（默认）
  * 开关：是否启用 OCR（默认 Auto）
  * 提交 → 创建 job

**关键 API**

* `GET /api/sections/:id/docs`
* `POST /api/dedup/jobs`

---

### A3.2 任务详情页 JobDetail（进度 + pair 矩阵）

**UI**

* 进度条：解析进度、LLM 调用进度、报告生成进度
* 投标人矩阵热力图（20×20，上三角）

  * 单元格点击 → 进入 pair 的命中列表/或跳到最高命中
* Pair 列表（按风险排序）：A vs B、最高分、命中数、状态

**关键 API**

* `GET /api/dedup/jobs/:jobId`
* `GET /api/dedup/jobs/:jobId/reports`
* `GET /api/dedup/reports/:reportId/pairs`（可选）

---

### A3.3 报告概览页 ReportOverview（命中清单）

**UI**

* 统计卡片：高风险数量/中风险/低风险、Top 命中章节
* 筛选器：

  * 风险等级、相似度区间、章节类型（技术/商务/服务/附件）、投标人A/B
* 命中列表 HitList（分页/虚拟滚动）：

  * 展示：相似度、章节、A页码、B页码、摘要、规则命中标签
  * 操作：**对照查看**（进入 CompareViewer）

**关键 API**

* `GET /api/dedup/reports/:reportId/hits?filters...`

---

## A4. 核心页面 CompareViewer（双栏 PDF 跳页高亮）

### A4.1 页面布局（经典 B 端）

* 左侧：HitList（可折叠 Drawer）
* 中间：双栏 PDF Viewer（左 docA / 右 docB）
* 右侧：EvidenceCard（证据卡）

  * 相似度、改写风险、命中规则、LLM解释、人工结论按钮
* 顶部：命中导航

  * 上一处/下一处、快捷键（↑↓ 或 J/K）、同步滚动开关

### A4.2 数据流（必须清晰）

1. 页面进入：`hitId` → `GET /hits/{hitId}` 拿 docA/docB/reportId
2. 并行加载：

   * `GET /files/{docId}/preview` 获取预览 PDF URL（给 PDF.js）
   * `GET /dedup/hits/{hitId}/anchors` 获取 anchors（A/B 页码+bbox+snippet）
3. 自动跳转到第一处命中：

   * 左 viewer：goToPage(anchorA.page)
   * 右 viewer：goToPage(anchorB.page)
   * 绘制 overlay 高亮 bbox_list

### A4.3 PDF.js 高亮实现（工程要点）

建议抽象一个 `PdfViewer` 组件，内部管理 PDF.js 实例，暴露方法：

* `load(url)`
* `goTo(pageNumber)`
* `setHighlights(highlights: {page:number, bboxList:number[][]}[])`

**坐标体系建议：归一化坐标**

* 入库时 bbox 统一存为相对坐标 `[x1,y1,x2,y2]` in **0..1**（相对于页面宽高）
* 前端根据当前缩放与渲染 viewport 将归一化 bbox 转成像素
* 优点：缩放/不同分辨率都不漂移

**Overlay 层**

* 每页渲染容器上加一个绝对定位层 `div.overlay-layer`
* 在 overlay-layer 中渲染 `div.highlight-rect`（或 canvas）
* 每次跳页后，按 page 过滤 highlights 渲染

**命中导航**

* anchors 通常是多条，维护 `currentIndex`
* next/prev 更新 index → 调用两侧 `goTo` 并刷新 overlay

### A4.4 EvidenceCard（证据卡）字段规范

* 相似度（0-100）
* 改写风险（LOW/MED/HIGH）
* 命中规则（标签）
* 命中片段摘要（A snippet / B snippet）
* LLM 解释（可折叠）
* 人工结论：

  * 确认为疑似 / 误报 / 待定
  * 备注文本框
  * 保存 → `POST /hits/{hitId}/review`

---

## A5. Pinia Store 设计（最小必要）

* `useUserStore`：用户、角色、权限
* `useDedupStore`：

  * currentJob、currentReport
  * hits filters（可缓存到 URL query）
  * compareViewerState（hitId、anchors、currentIndex、syncScroll）

---

# B. 后端细化（架构、任务编排、幂等、缓存、DDL、错误码）

## B1. 运行时架构（推荐单体分层 + 可拆服务）

在你们规模（≤20份/标段）下，一期可采用“**模块化单体** + 队列”，后续再拆服务。

模块分层：

* API 层：鉴权、参数校验、错误码
* Domain 层：job/report/hit/anchor 模型与规则
* Infra 层：对象存储、PDF/转换、OCR adapter、LLM adapter、队列、DB

队列建议：

* Redis Queue（最容易落地）
* Worker 独立进程：`anchor-worker`、`dedup-worker`

---

## B2. 任务编排（Job DAG）

### B2.1 Job 阶段定义

一个 job 分 4 阶段（每阶段可重试、可部分成功）：

1. **ANCHORING**：生成页码锚定（doc_page/doc_line）
2. **PAIRING**：生成 pairs（<=190）
3. **LLM_MATCHING**：对每对 doc 做对齐+精算，产出 hits/anchors
4. **REPORTING**：聚合风险分、统计、报告可读字段

### B2.2 并发策略（默认参数）

* 文件数 ≤20，pairs ≤190
* 建议并发：

  * anchoring：并发 2~3（防止转换/OCR占用）
  * llm-matching：并发 5（可配置）
* 单对 doc 内部：

  * align 1 次
  * compare block pairs ≤30 次（控制成本的关键）

---

## B3. 幂等与重试（必须）

### B3.1 幂等键

* `file_sha256`：同文件重复上传 → 复用解析结果（doc_version 指向同解析产物）
* `anchor_idempotent_key = sha256(doc_id + version_id + parse_config_version)`
* `llm_cache_key = sha256(model + prompt_version + normalize(textA) + normalize(textB))`
* `ocr_cache_key = sha256(page_image_bytes + ocr_provider + ocr_config_version)`

### B3.2 重试策略（推荐）

* OCR/LLM：指数退避重试 2 次
* 超时：直接标记该 pair 为 `PARTIAL`，不阻塞全 job
* 熔断：provider 连续失败 N 次 → provider 暂停 T 分钟（仅对该 provider）

---

## B4. 缓存策略（成本控制核心）

### B4.1 LLM 结果缓存表（强缓存）

* 同一对文本，promptVersion 不变 → 直接命中缓存
* 缓存 TTL：建议 180 天（文件归档周期内）

### B4.2 OCR 缓存

* 页级缓存，复用极强（尤其是重复上传/替换小修改）
* OCR 结果与 bbox 可直接复用

---

## B5. LLM 调用治理（外接算力的“可控性”）

### B5.1 三类调用目的

* `ALIGN`：章节/块对齐（输入：双方块摘要清单）
* `COMPARE`：块对块语义比对（输入：两段正文）
* `EXPLAIN`：生成解释（可并入 COMPARE 输出）

### B5.2 结构化输出校验（强约束）

后端必须对 LLM 返回做 JSON Schema 校验：

* 不通过 → 记日志、重试一次；仍失败则降级为“无解释/只给相似度”

### B5.3 默认 prompt 版本策略

* prompt 版本化：`prompt_template(prompt_version, type, text)`
* job 固化使用的 prompt_version，保证可追溯

---

## B6. DDL 草案（PostgreSQL，关键表）

下面给你可直接落库的核心字段（省略索引细节，但把关键索引点也写上）。

```sql
-- 文档
create table doc (
  doc_id            uuid primary key,
  section_id        uuid not null,
  bidder_id         uuid,
  filename          text not null,
  sha256            char(64) not null,
  file_type         text not null, -- pdf/docx
  created_at        timestamptz not null default now()
);
create index idx_doc_section on doc(section_id);
create unique index uidx_doc_section_sha on doc(section_id, sha256);

create table doc_version (
  version_id        uuid primary key,
  doc_id            uuid not null references doc(doc_id),
  file_url          text not null,
  preview_pdf_url   text,
  parse_status      text not null default 'PENDING',
  parse_config_ver  text not null,
  created_at        timestamptz not null default now()
);
create index idx_docver_doc on doc_version(doc_id);

-- 页与行（锚定）
create table doc_page (
  page_id           uuid primary key,
  doc_id            uuid not null references doc(doc_id),
  page_no           int not null,
  width             int,
  height            int,
  has_text_layer    boolean not null default false,
  image_url         text, -- 可选：页渲染图
  unique(doc_id, page_no)
);
create index idx_page_doc on doc_page(doc_id);

create table doc_line (
  line_id           uuid primary key,
  doc_id            uuid not null references doc(doc_id),
  page_no           int not null,
  bbox              jsonb not null, -- [x1,y1,x2,y2] 0..1 归一化
  text              text not null,
  norm_text         text not null,
  confidence        float,
  block_tag         text, -- title/paragraph/table/header/footer
  created_at        timestamptz not null default now()
);
create index idx_line_doc_page on doc_line(doc_id, page_no);

-- 查重任务
create table dedup_job (
  job_id            uuid primary key,
  section_id        uuid not null,
  mode              text not null, -- FAST/STANDARD/DEEP
  status            text not null default 'PENDING',
  progress          int not null default 0,
  llm_provider_id   uuid,
  ocr_provider_id   uuid,
  prompt_version    text not null,
  created_by        uuid,
  created_at        timestamptz not null default now()
);
create index idx_job_section on dedup_job(section_id);

create table dedup_pair (
  pair_id           uuid primary key,
  job_id            uuid not null references dedup_job(job_id),
  doc_a             uuid not null references doc(doc_id),
  doc_b             uuid not null references doc(doc_id),
  status            text not null default 'PENDING',
  score_summary     int,
  created_at        timestamptz not null default now(),
  unique(job_id, doc_a, doc_b)
);

create table dedup_hit (
  hit_id            uuid primary key,
  pair_id           uuid not null references dedup_pair(pair_id),
  score             int not null, -- 0-100
  rewrite_risk      text, -- LOW/MED/HIGH
  rule_hits         jsonb, -- 命中规则标签
  explanation       text,
  a_page_hint       int,
  b_page_hint       int,
  created_at        timestamptz not null default now()
);
create index idx_hit_pair on dedup_hit(pair_id);
create index idx_hit_score on dedup_hit(score desc);

create table dedup_anchor (
  anchor_id         uuid primary key,
  hit_id            uuid not null references dedup_hit(hit_id),
  doc_id            uuid not null references doc(doc_id),
  page_no           int not null,
  bbox_list         jsonb not null, -- [[x1,y1,x2,y2],...]
  snippet           text,
  confidence        float,
  created_at        timestamptz not null default now()
);
create index idx_anchor_hit on dedup_anchor(hit_id);

-- 人工复核
create table hit_review (
  review_id         uuid primary key,
  hit_id            uuid not null references dedup_hit(hit_id),
  result            text not null, -- CONFIRMED/FALSE_POSITIVE/PENDING
  remark            text,
  reviewed_by       uuid,
  reviewed_at       timestamptz not null default now()
);

-- Provider 配置
create table provider_config (
  provider_id       uuid primary key,
  type              text not null, -- LLM/OCR
  name              text not null,
  endpoint          text not null,
  model             text,
  encrypted_key     text not null,
  timeout_ms        int not null default 8000,
  qps               int not null default 5,
  concurrency       int not null default 5,
  enabled           boolean not null default true,
  created_at        timestamptz not null default now()
);

-- 调用日志与缓存（关键）
create table invoke_log (
  invoke_id         uuid primary key,
  provider_id       uuid not null references provider_config(provider_id),
  job_id            uuid,
  purpose           text not null, -- ALIGN/COMPARE/OCR
  input_hash        char(64) not null,
  cache_hit         boolean not null default false,
  latency_ms        int,
  status            text not null, -- OK/ERR/TIMEOUT
  error_code        text,
  created_at        timestamptz not null default now()
);
create index idx_invokelog_job on invoke_log(job_id);

create table llm_cache (
  cache_key         char(64) primary key,
  provider_id       uuid not null references provider_config(provider_id),
  purpose           text not null,
  prompt_version    text not null,
  response_json     jsonb not null,
  created_at        timestamptz not null default now()
);
```

---

## B7. 关键算法/逻辑：从 LLM spans 到 bbox_list

### B7.1 你必须提前准备的映射能力

* `doc_line` 已经是“行级”并带 bbox（最稳）
* LLM 输出 matched_spans（句子列表/片段）
* 后端做：

  1. 对每条 span 进行 norm（同样的规范化）
  2. 在 `doc_line.norm_text` 中找包含/相似的行（可用：

     * 包含匹配
     * n-gram overlap ≥ 阈值
     * 编辑距离 ≤ 阈值（只在少量候选行里做）
  3. 命中行的 bbox 组成 bbox_list

> 这样你不需要让大模型输出坐标，它只输出文本片段即可。

---

## B8. API 细化（含返回字段给前端直接用）

### B8.1 发起任务

`POST /api/dedup/jobs`

```json
{
  "section_id": "...",
  "doc_ids": ["..."],
  "mode": "STANDARD",
  "llm_provider_id": "...",
  "ocr_provider_id": "...",
  "prompt_version": "v1.0",
  "options": {"ocr":"AUTO"}
}
```

返回：

```json
{"job_id":"...", "status":"PENDING"}
```

### B8.2 报告命中列表（给 ReportOverview）

`GET /api/dedup/reports/:reportId/hits?...`
返回每条至少包含：

```json
{
  "hit_id":"...",
  "score":86,
  "rewrite_risk":"HIGH",
  "rule_hits":["TECH_PLAN_SIMILAR","STRUCTURE_SIMILAR"],
  "a":{"doc_id":"A","bidder":"X","page_hint":12,"snippet":"..."},
  "b":{"doc_id":"B","bidder":"Y","page_hint":15,"snippet":"..."}
}
```

### B8.3 CompareViewer 获取 anchors

`GET /api/dedup/hits/:hitId/anchors`
返回：

```json
{
  "hit_id":"...",
  "a_preview_url":"...",
  "b_preview_url":"...",
  "anchors":[
    {
      "a":{"page":12,"bbox_list":[[0.1,0.2,0.9,0.25]],"snippet":"..."},
      "b":{"page":15,"bbox_list":[[0.12,0.18,0.88,0.23]],"snippet":"..."}
    }
  ],
  "explanation":"...",
  "score":86,
  "rewrite_risk":"HIGH"
}
```

---

## B9. 错误码规范（前后端统一）

建议统一格式：

```json
{ "code":"DEDUP_LLM_TIMEOUT", "message":"...", "trace_id":"..." }
```

基础错误码：

* `AUTH_UNAUTHORIZED` / `AUTH_FORBIDDEN`
* `REQ_INVALID_PARAM`
* `FILE_UNSUPPORTED_TYPE`
* `ANCHOR_PARSE_FAILED`
* `OCR_PROVIDER_ERROR`
* `LLM_PROVIDER_ERROR`
* `DEDUP_LLM_TIMEOUT`
* `DEDUP_SCHEMA_INVALID`（LLM JSON 不符合 schema）
* `JOB_NOT_FOUND` / `REPORT_NOT_FOUND` / `HIT_NOT_FOUND`

前端策略：

* timeout/partial：提示“已生成部分结果，可继续重试补全”
* schema invalid：提示“解释暂不可用，不影响定位查看”

---

## B10. 默认参数（针对≤20份/标段）

* mode=STANDARD：

  * 每对 doc：LLM align 1 次
  * block pairs 上限：30
  * compare 并发：5
  * OCR：AUTO（仅扫描件 & 仅疑似页；上限每文档 10 页）
* 阈值：

  * 高风险：score ≥ 80
  * 中风险：60–79
  * 低风险：40–59

---

# C. 你可以直接拿去评审的“开发任务拆解”（一期）

1. 文件接入 + 预览（PDF/DOCX 转 PDF）
2. Anchor：PDF text layer 抽取 line+bbox；扫描件 OCR adapter + line+bbox
3. Job/Pair/Hit/Anchor 表结构 + API
4. LLM Provider 配置中心 + 调用治理（缓存/限流/熔断/日志）
5. Dedup Engine：轻候选（可先简单）+ LLM align/compare + spans→bbox 映射
6. Vue3：

   * SectionDetail、JobDetail、ReportOverview
   * CompareViewer（PDF.js 双栏跳页高亮 + 证据卡 + 复核）
7. 导出与审计（至少：报告导出 HTML/PDF + invoke_log 查询）

---

